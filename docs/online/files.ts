export const files = {
  "input.ts": {
    "file": {
      "contents": "class Data {\n  name: string;\n  title: string;\n}\n"
    }
  },
  "index.js": {
    "file": {
      "contents": "import express from \"express\";\nconst app = express();\nconst port = 3111;\n\nimport { parser } from \"./parser.js\";\n\napp.get(\"/\", (req, res) => {\n  res.send(\"Welcome to a TSaid! 🥳\");\n});\n\napp.get(\"/rerun\", (req, res) => {\n  let ans = \"NONE\";\n  try {\n    ans = parser();\n  } catch (error) {\n    ans = error.toString();\n  }\n  res.json({ ans });\n});\n\napp.listen(port, () => {\n  console.log(`App is live at http://localhost:${port}`);\n});\n"
    }
  },
  "package.json": {
    "file": {
      "contents": "{\n  \"dependencies\": {\n    \"express\": \"latest\",\n    \"nodemon\": \"latest\",\n    \"ts-morph\": \"latest\",\n    \"typescript\": \"latest\"\n  },\n  \"name\": \"example-app\",\n  \"scripts\": {\n    \"start\": \"nodemon index.js\"\n  },\n  \"type\": \"module\"\n}"
    }
  },
  "parser.js": {
    "file": {
      "contents": "import { Project } from \"ts-morph\";\nimport { getDtsNodes, parseDefinitions } from \"./tsaid.js\";\n\nexport const parser = () => {\n  const project = new Project({});\n  const args = [\"./input.ts\"];\n  // const args = [\"./cases/**/*.ts\"];\n  args.forEach((glob) => {\n    project.addSourceFilesAtPaths(glob);\n  });\n  const { definitions, operations } = getDtsNodes(project);\n  // const oops = path.resolve(\"./output/ops.json\");\n  // const odefs = path.resolve(\"./output/defs.json\");\n  // fs.writeFileSync(oops, \"\", \"utf-8\");\n  // fs.writeFileSync(odefs, \"\", \"utf-8\");\n\n  const { defSchema, defNameMap } = parseDefinitions(definitions);\n  // const opSchema = parseOperations(operations, defNameMap);\n  // fs.writeFileSync(odefs, JSON.stringify(defSchema, null, 2), \"utf-8\");\n  // fs.writeFileSync(oops, JSON.stringify(opSchema, null, 2), \"utf-8\");\n  // console.log(\"🚀 success!\");\n  return JSON.stringify(defSchema, null, 2);\n};\n"
    }
  },
  "tsaid.js": {
    "file": {
      "contents": "import { Node } from 'ts-morph';\n\n/**\n * 获取节点的额外信息，包括装饰器、JSDoc注释、前置注释和后置注释\n * @param node 支持的节点类型：ClassDeclaration、PropertyDeclaration、TypeAliasDeclaration、PropertySignature\n * @returns 返回解析后的节点信息对象\n */\nconst getNodeExtraInfo = (node) => {\n    var _a, _b;\n    // 获取装饰器信息，仅适用于类和类属性\n    const decorators = Node.isClassDeclaration(node) || Node.isPropertyDeclaration(node)\n        ? node.getDecorators().reduce((map, dec) => {\n            const propName = dec.getName();\n            const propValue = dec\n                .getArguments()\n                .map((arg) => arg.getFullText())\n                .join(\"/\");\n            map[propName] = propValue;\n            return map;\n        }, {})\n        : {};\n    // 获取JSDoc标签信息，注意不支持 @type\n    const jsDocs = node.getJsDocs().reduce((map, doc) => {\n        const tags = doc\n            .getTags()\n            .filter((tag) => Node.isJSDocTag(tag) || Node.isJSDocDeprecatedTag(tag))\n            .reduce((tmap, tag) => {\n            tmap[tag.getTagName()] = tag.getCommentText();\n            return tmap;\n        }, {});\n        return Object.assign(Object.assign({}, map), tags);\n    }, {});\n    // 获取前置注释，若存在则取最后一行\n    const leadingComment = (_b = (_a = node.getLeadingCommentRanges().pop()) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : \"\";\n    // 获取所有后置注释并合并为一个字符串\n    const trailingComment = node\n        .getTrailingCommentRanges()\n        .map((cmm) => cmm.getText())\n        .join(\"\\n\");\n    // 优先级：JSDoc description > 装饰器 description > 前置注释 > 后置注释\n    const desc = jsDocs.description ||\n        decorators.description ||\n        leadingComment ||\n        trailingComment;\n    // 合并所有信息\n    const merged = Object.assign(Object.assign({}, jsDocs), decorators);\n    // 如果存在描述，则添加到合并对象中\n    if (desc) {\n        merged.description = desc;\n    }\n    return { decorators, jsDocs, leadingComment, trailingComment, merged };\n};\n\n// 忽略规则的键\nconst IgnoreRuleKeys = {\n    jsDoc: [\"ignore\", \"WIP\", \"Draft\"],\n    classDecorators: [\"ignore\", \"WIP\", \"Draft\"],\n    leadingComment: [\"@ignore\", \"@WIP\", \"@Draft\"],\n};\n// 判断是否应跳过该节点\nconst shouldSkip = (node) => {\n    const { decorators, jsDocs, leadingComment } = getNodeExtraInfo(node);\n    // 检查装饰器中是否有忽略标签\n    const skipByDecorator = Object.keys(decorators).findIndex((decoratorName) => IgnoreRuleKeys.classDecorators.includes(decoratorName)) > -1;\n    if (skipByDecorator)\n        return true;\n    // 检查 jsDoc 中是否有忽略标签\n    const skipByJsDoc = Object.keys(jsDocs).findIndex((tagName) => IgnoreRuleKeys.jsDoc.includes(tagName)) > -1;\n    if (skipByJsDoc)\n        return true;\n    // 检查前导注释中是否有忽略标签\n    const skipByComment = leadingComment\n        .split(/\\s+/)\n        .findIndex((word) => IgnoreRuleKeys.leadingComment.includes(word)) > -1;\n    if (skipByComment)\n        return true;\n    return false; // 如果没有任何忽略标签，返回 false\n};\n// 获取项目中的 d.ts 节点\nconst getDtsNodes = (project) => {\n    const typings = [];\n    const definitions = [];\n    const operations = [];\n    const unique = {};\n    project.getSourceFiles().forEach((sourceFile) => {\n        sourceFile.getStatements().forEach((statement) => {\n            // 处理类声明\n            if (Node.isClassDeclaration(statement)) {\n                if (shouldSkip(statement))\n                    return; // 跳过被忽略的节点\n                definitions.push(statement);\n            }\n            // 处理类型别名声明\n            if (Node.isTypeAliasDeclaration(statement)) {\n                const typ = statement.getTypeNode();\n                if (shouldSkip(statement))\n                    return; // 跳过被忽略的节点\n                // 如果是带有泛型的说明是一些辅助类型定义, 虽然暂时没有什么用, 但是先保起来\n                const typeParams = statement.getTypeParameters();\n                // 仅处理有泛型参数的类型别名\n                if (typeParams.length > 0) {\n                    typings.push(statement);\n                }\n                // 否则就看是不是 ApiOperation 定义\n                // 条件是必须是 TypeLiteral 字面量定义\n                if (Node.isTypeLiteral(typ)) {\n                    const operation = statement;\n                    // 必须有 url 字段\n                    const hasUrl = operation.getType().getProperty(\"url\");\n                    if (hasUrl) {\n                        const name = operation.getName();\n                        if (unique[name]) {\n                            throw new Error(\"Api 操作定义出现了重复\" +\n                                name +\n                                \"重复定义所在文件: \" +\n                                unique[name].getSourceFile().getFilePath() +\n                                \":\" +\n                                unique[name].getStartLineNumber() // 使用 getLine() 获取行号\n                            );\n                        }\n                        operations.push(operation);\n                        unique[name] = operation; // 记录唯一的操作\n                    }\n                }\n            }\n        });\n    });\n    return {\n        typings,\n        definitions,\n        operations,\n    };\n};\n\nconst resolveLiteral = (type) => {\n    if (type.isLiteral) {\n        return {\n            const: type.getLiteralValue(),\n        };\n    }\n    else {\n        return {};\n    }\n};\nconst resolveType = (info) => {\n    const { type, defNameMap, extra = {}, circularRefs = new WeakMap(), } = info;\n    // 输出调试信息,帮助理解类型结构\n    // console.log(\"\\n=== Resolving Type ===\", debugType(type));\n    // 收集类型的相关信息用于调试\n    // const debug = collectDebugInfo(type, typeNode);\n    const base = Object.assign(Object.assign(Object.assign({}, extra), { _code: type.getText() }), resolveLiteral(type));\n    // 检测并处理循环引用\n    if (circularRefs.has(type)) {\n        return Object.assign(Object.assign({}, base), { $ref: circularRefs.get(type) });\n    }\n    if (type.getSymbol()) {\n        // 检查属性类型是否是已定义的类型\n        const maybeTypeDecl = type.getSymbol().getValueDeclaration();\n        const isDefinedType = defNameMap.has(maybeTypeDecl);\n        // 如果是已定义类型,使用引用\n        if (isDefinedType) {\n            return Object.assign(Object.assign({}, base), { $ref: \"#\" + defNameMap.get(maybeTypeDecl) });\n        }\n    }\n    // 处理基本类型和字面量类型\n    if (type.isString() || type.isStringLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"string\" });\n    }\n    if (type.isNumber() || type.isNumberLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"number\" });\n    }\n    if (type.isBoolean() || type.isBooleanLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"boolean\" });\n    }\n    // 处理其他字面量类型\n    if (type.isLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"string\" });\n    }\n    // 处理数组类型\n    if (type.isArray()) {\n        return Object.assign(Object.assign({}, base), { type: \"array\", items: resolveType({\n                type: type.getArrayElementType(),\n                defNameMap,\n                circularRefs,\n            }) });\n    }\n    if (type.isUnion()) {\n        circularRefs.set(type, type.getText());\n        return Object.assign(Object.assign({}, base), { oneOf: type.getUnionTypes().map((subType) => resolveType({\n                type: subType,\n                defNameMap,\n                extra,\n                circularRefs,\n            })) });\n    }\n    if (type.isIntersection()) {\n        circularRefs.set(type, type.getText());\n        return Object.assign(Object.assign({}, base), { type: \"array\", allOf: type.getIntersectionTypes().map((subType) => {\n                return resolveType({\n                    type: subType,\n                    defNameMap,\n                    extra,\n                    circularRefs,\n                });\n            }) });\n    }\n    // 处理对象类型和交叉类型\n    if (type.isObject()) {\n        circularRefs.set(type, type.getText());\n        return Object.assign(Object.assign({}, base), { type: \"object\", properties: type.getProperties().reduce((map, propSymbol) => {\n                // const debug = collectDebugInfo(null, null, propSymbol);\n                var _a, _b;\n                // 获取属性的声明节点\n                const propNode = (_a = propSymbol.getValueDeclaration()) !== null && _a !== void 0 ? _a : propSymbol.getDeclarations()[0];\n                // 获取属性的类型\n                const propType = propNode\n                    ? propSymbol.getTypeAtLocation(propNode)\n                    : propSymbol.getDeclaredType();\n                // 检查属性类型是否是已定义的类型\n                const maybeTypeDecl = (_b = propType.getSymbol()) === null || _b === void 0 ? void 0 : _b.getValueDeclaration();\n                const isDefinedType = maybeTypeDecl && defNameMap.has(maybeTypeDecl);\n                // 如果是已定义类型,使用引用\n                if (isDefinedType) {\n                    map[propSymbol.getName()] = {\n                        $ref: \"#\" + defNameMap.get(maybeTypeDecl),\n                    };\n                    return map;\n                }\n                // 递归处理属性类型\n                map[propSymbol.getName()] = resolveType({\n                    type: propType,\n                    defNameMap,\n                    circularRefs,\n                });\n                return map;\n            }, {}) });\n    }\n};\nconst parseDefinitions = (definitions) => {\n    const defSchema = {};\n    const defNameMap = new WeakMap();\n    for (const def of definitions) {\n        let clzName = def.getName();\n        // 检查是否存在重复名称\n        if (defSchema[clzName]) {\n            const atFile = def.getSourceFile().getFilePath();\n            const basechain = atFile.split(\"/\");\n            clzName =\n                clzName + \"_At_\" + basechain[basechain.length - 1].replace(/\\.w+/, \"\");\n            let acc = 0;\n            const baseName = clzName;\n            // 生成唯一名称\n            while (defSchema[clzName]) {\n                acc = acc + 1;\n                clzName = baseName + acc;\n            }\n        }\n        defNameMap.set(def, clzName);\n    }\n    for (const def of definitions) {\n        const extra = getNodeExtraInfo(def);\n        let clzName = defNameMap.get(def);\n        const schema = Object.assign(Object.assign({}, extra.merged), { type: \"object\", properties: def.getProperties().reduce((map, prop) => {\n                const extra = getNodeExtraInfo(prop);\n                map[prop.getName()] = resolveType({\n                    type: prop.getType(),\n                    defNameMap: defNameMap,\n                    extra: extra.merged,\n                });\n                return map;\n            }, {}) });\n        defSchema[clzName] = schema;\n    }\n    return { defSchema, defNameMap };\n};\nconst parseOperations = (operations, defNameMap) => {\n    const defMap = {};\n    for (const operation of operations) {\n        const extra = getNodeExtraInfo(operation);\n        const typeNode = operation.getTypeNode();\n        if (Node.isTypeLiteral(typeNode)) {\n            const schema = Object.assign(Object.assign({}, extra.merged), { type: \"object\", properties: typeNode.getProperties().reduce((map, prop) => {\n                    const extra = getNodeExtraInfo(prop);\n                    map[prop.getName()] = resolveType({\n                        type: prop.getType(),\n                        defNameMap,\n                        extra: extra.merged,\n                    });\n                    return map;\n                }, {}) });\n            defMap[operation.getName()] = schema;\n        }\n    }\n    return defMap;\n};\n\nexport { getDtsNodes, getNodeExtraInfo, parseDefinitions, parseOperations };\n"
    }
  }
}