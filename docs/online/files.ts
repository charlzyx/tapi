export const files = {
  "input.ts": {
    "file": {
      "contents": "class Data {\n  name: string;\n  title: string;\n}\n"
    }
  },
  "index.js": {
    "file": {
      "contents": "import express from \"express\";\nconst app = express();\nconst port = 3111;\n\nimport { parser } from \"./parser.js\";\n\napp.get(\"/\", (req, res) => {\n  res.send(\"Welcome to a TSaid! ðŸ¥³\");\n});\n\napp.get(\"/rerun\", (req, res) => {\n  let ans = \"NONE\";\n  try {\n    ans = parser();\n  } catch (error) {\n    ans = error.toString();\n  }\n  res.json({ ans });\n});\n\napp.listen(port, () => {\n  console.log(`App is live at http://localhost:${port}`);\n});\n"
    }
  },
  "package.json": {
    "file": {
      "contents": "{\n  \"dependencies\": {\n    \"express\": \"latest\",\n    \"nodemon\": \"latest\",\n    \"ts-morph\": \"latest\",\n    \"typescript\": \"latest\"\n  },\n  \"name\": \"example-app\",\n  \"scripts\": {\n    \"start\": \"nodemon index.js\"\n  },\n  \"type\": \"module\"\n}"
    }
  },
  "parser.js": {
    "file": {
      "contents": "import { Project } from \"ts-morph\";\nimport { getDtsNodes, parseDefinitions } from \"./tsaid.js\";\n\nexport const parser = () => {\n  const project = new Project({});\n  const args = [\"./input.ts\"];\n  // const args = [\"./cases/**/*.ts\"];\n  args.forEach((glob) => {\n    project.addSourceFilesAtPaths(glob);\n  });\n  const { definitions, operations } = getDtsNodes(project);\n  // const oops = path.resolve(\"./output/ops.json\");\n  // const odefs = path.resolve(\"./output/defs.json\");\n  // fs.writeFileSync(oops, \"\", \"utf-8\");\n  // fs.writeFileSync(odefs, \"\", \"utf-8\");\n\n  const { defSchema, defNameMap } = parseDefinitions(definitions);\n  // const opSchema = parseOperations(operations, defNameMap);\n  // fs.writeFileSync(odefs, JSON.stringify(defSchema, null, 2), \"utf-8\");\n  // fs.writeFileSync(oops, JSON.stringify(opSchema, null, 2), \"utf-8\");\n  // console.log(\"ðŸš€ success!\");\n  return JSON.stringify(defSchema, null, 2);\n};\n"
    }
  },
  "tsaid.js": {
    "file": {
      "contents": "import { Node } from 'ts-morph';\n\n/**\n * èŽ·å–èŠ‚ç‚¹çš„é¢å¤–ä¿¡æ¯ï¼ŒåŒ…æ‹¬è£…é¥°å™¨ã€JSDocæ³¨é‡Šã€å‰ç½®æ³¨é‡Šå’ŒåŽç½®æ³¨é‡Š\n * @param node æ”¯æŒçš„èŠ‚ç‚¹ç±»åž‹ï¼šClassDeclarationã€PropertyDeclarationã€TypeAliasDeclarationã€PropertySignature\n * @returns è¿”å›žè§£æžåŽçš„èŠ‚ç‚¹ä¿¡æ¯å¯¹è±¡\n */\nconst getNodeExtraInfo = (node) => {\n    var _a, _b;\n    // èŽ·å–è£…é¥°å™¨ä¿¡æ¯ï¼Œä»…é€‚ç”¨äºŽç±»å’Œç±»å±žæ€§\n    const decorators = Node.isClassDeclaration(node) || Node.isPropertyDeclaration(node)\n        ? node.getDecorators().reduce((map, dec) => {\n            const propName = dec.getName();\n            const propValue = dec\n                .getArguments()\n                .map((arg) => arg.getFullText())\n                .join(\"/\");\n            map[propName] = propValue;\n            return map;\n        }, {})\n        : {};\n    // èŽ·å–JSDocæ ‡ç­¾ä¿¡æ¯ï¼Œæ³¨æ„ä¸æ”¯æŒ @type\n    const jsDocs = node.getJsDocs().reduce((map, doc) => {\n        const tags = doc\n            .getTags()\n            .filter((tag) => Node.isJSDocTag(tag) || Node.isJSDocDeprecatedTag(tag))\n            .reduce((tmap, tag) => {\n            tmap[tag.getTagName()] = tag.getCommentText();\n            return tmap;\n        }, {});\n        return Object.assign(Object.assign({}, map), tags);\n    }, {});\n    // èŽ·å–å‰ç½®æ³¨é‡Šï¼Œè‹¥å­˜åœ¨åˆ™å–æœ€åŽä¸€è¡Œ\n    const leadingComment = (_b = (_a = node.getLeadingCommentRanges().pop()) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : \"\";\n    // èŽ·å–æ‰€æœ‰åŽç½®æ³¨é‡Šå¹¶åˆå¹¶ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²\n    const trailingComment = node\n        .getTrailingCommentRanges()\n        .map((cmm) => cmm.getText())\n        .join(\"\\n\");\n    // ä¼˜å…ˆçº§ï¼šJSDoc description > è£…é¥°å™¨ description > å‰ç½®æ³¨é‡Š > åŽç½®æ³¨é‡Š\n    const desc = jsDocs.description ||\n        decorators.description ||\n        leadingComment ||\n        trailingComment;\n    // åˆå¹¶æ‰€æœ‰ä¿¡æ¯\n    const merged = Object.assign(Object.assign({}, jsDocs), decorators);\n    // å¦‚æžœå­˜åœ¨æè¿°ï¼Œåˆ™æ·»åŠ åˆ°åˆå¹¶å¯¹è±¡ä¸­\n    if (desc) {\n        merged.description = desc;\n    }\n    return { decorators, jsDocs, leadingComment, trailingComment, merged };\n};\n\n// å¿½ç•¥è§„åˆ™çš„é”®\nconst IgnoreRuleKeys = {\n    jsDoc: [\"ignore\", \"WIP\", \"Draft\"],\n    classDecorators: [\"ignore\", \"WIP\", \"Draft\"],\n    leadingComment: [\"@ignore\", \"@WIP\", \"@Draft\"],\n};\n// åˆ¤æ–­æ˜¯å¦åº”è·³è¿‡è¯¥èŠ‚ç‚¹\nconst shouldSkip = (node) => {\n    const { decorators, jsDocs, leadingComment } = getNodeExtraInfo(node);\n    // æ£€æŸ¥è£…é¥°å™¨ä¸­æ˜¯å¦æœ‰å¿½ç•¥æ ‡ç­¾\n    const skipByDecorator = Object.keys(decorators).findIndex((decoratorName) => IgnoreRuleKeys.classDecorators.includes(decoratorName)) > -1;\n    if (skipByDecorator)\n        return true;\n    // æ£€æŸ¥ jsDoc ä¸­æ˜¯å¦æœ‰å¿½ç•¥æ ‡ç­¾\n    const skipByJsDoc = Object.keys(jsDocs).findIndex((tagName) => IgnoreRuleKeys.jsDoc.includes(tagName)) > -1;\n    if (skipByJsDoc)\n        return true;\n    // æ£€æŸ¥å‰å¯¼æ³¨é‡Šä¸­æ˜¯å¦æœ‰å¿½ç•¥æ ‡ç­¾\n    const skipByComment = leadingComment\n        .split(/\\s+/)\n        .findIndex((word) => IgnoreRuleKeys.leadingComment.includes(word)) > -1;\n    if (skipByComment)\n        return true;\n    return false; // å¦‚æžœæ²¡æœ‰ä»»ä½•å¿½ç•¥æ ‡ç­¾ï¼Œè¿”å›ž false\n};\n// èŽ·å–é¡¹ç›®ä¸­çš„ d.ts èŠ‚ç‚¹\nconst getDtsNodes = (project) => {\n    const typings = [];\n    const definitions = [];\n    const operations = [];\n    const unique = {};\n    project.getSourceFiles().forEach((sourceFile) => {\n        sourceFile.getStatements().forEach((statement) => {\n            // å¤„ç†ç±»å£°æ˜Ž\n            if (Node.isClassDeclaration(statement)) {\n                if (shouldSkip(statement))\n                    return; // è·³è¿‡è¢«å¿½ç•¥çš„èŠ‚ç‚¹\n                definitions.push(statement);\n            }\n            // å¤„ç†ç±»åž‹åˆ«åå£°æ˜Ž\n            if (Node.isTypeAliasDeclaration(statement)) {\n                const typ = statement.getTypeNode();\n                if (shouldSkip(statement))\n                    return; // è·³è¿‡è¢«å¿½ç•¥çš„èŠ‚ç‚¹\n                // å¦‚æžœæ˜¯å¸¦æœ‰æ³›åž‹çš„è¯´æ˜Žæ˜¯ä¸€äº›è¾…åŠ©ç±»åž‹å®šä¹‰, è™½ç„¶æš‚æ—¶æ²¡æœ‰ä»€ä¹ˆç”¨, ä½†æ˜¯å…ˆä¿èµ·æ¥\n                const typeParams = statement.getTypeParameters();\n                // ä»…å¤„ç†æœ‰æ³›åž‹å‚æ•°çš„ç±»åž‹åˆ«å\n                if (typeParams.length > 0) {\n                    typings.push(statement);\n                }\n                // å¦åˆ™å°±çœ‹æ˜¯ä¸æ˜¯ ApiOperation å®šä¹‰\n                // æ¡ä»¶æ˜¯å¿…é¡»æ˜¯ TypeLiteral å­—é¢é‡å®šä¹‰\n                if (Node.isTypeLiteral(typ)) {\n                    const operation = statement;\n                    // å¿…é¡»æœ‰ url å­—æ®µ\n                    const hasUrl = operation.getType().getProperty(\"url\");\n                    if (hasUrl) {\n                        const name = operation.getName();\n                        if (unique[name]) {\n                            throw new Error(\"Api æ“ä½œå®šä¹‰å‡ºçŽ°äº†é‡å¤\" +\n                                name +\n                                \"é‡å¤å®šä¹‰æ‰€åœ¨æ–‡ä»¶: \" +\n                                unique[name].getSourceFile().getFilePath() +\n                                \":\" +\n                                unique[name].getStartLineNumber() // ä½¿ç”¨ getLine() èŽ·å–è¡Œå·\n                            );\n                        }\n                        operations.push(operation);\n                        unique[name] = operation; // è®°å½•å”¯ä¸€çš„æ“ä½œ\n                    }\n                }\n            }\n        });\n    });\n    return {\n        typings,\n        definitions,\n        operations,\n    };\n};\n\nconst resolveLiteral = (type) => {\n    if (type.isLiteral) {\n        return {\n            const: type.getLiteralValue(),\n        };\n    }\n    else {\n        return {};\n    }\n};\nconst resolveType = (info) => {\n    const { type, defNameMap, extra = {}, circularRefs = new WeakMap(), } = info;\n    // è¾“å‡ºè°ƒè¯•ä¿¡æ¯,å¸®åŠ©ç†è§£ç±»åž‹ç»“æž„\n    // console.log(\"\\n=== Resolving Type ===\", debugType(type));\n    // æ”¶é›†ç±»åž‹çš„ç›¸å…³ä¿¡æ¯ç”¨äºŽè°ƒè¯•\n    // const debug = collectDebugInfo(type, typeNode);\n    const base = Object.assign(Object.assign(Object.assign({}, extra), { _code: type.getText() }), resolveLiteral(type));\n    // æ£€æµ‹å¹¶å¤„ç†å¾ªçŽ¯å¼•ç”¨\n    if (circularRefs.has(type)) {\n        return Object.assign(Object.assign({}, base), { $ref: circularRefs.get(type) });\n    }\n    if (type.getSymbol()) {\n        // æ£€æŸ¥å±žæ€§ç±»åž‹æ˜¯å¦æ˜¯å·²å®šä¹‰çš„ç±»åž‹\n        const maybeTypeDecl = type.getSymbol().getValueDeclaration();\n        const isDefinedType = defNameMap.has(maybeTypeDecl);\n        // å¦‚æžœæ˜¯å·²å®šä¹‰ç±»åž‹,ä½¿ç”¨å¼•ç”¨\n        if (isDefinedType) {\n            return Object.assign(Object.assign({}, base), { $ref: \"#\" + defNameMap.get(maybeTypeDecl) });\n        }\n    }\n    // å¤„ç†åŸºæœ¬ç±»åž‹å’Œå­—é¢é‡ç±»åž‹\n    if (type.isString() || type.isStringLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"string\" });\n    }\n    if (type.isNumber() || type.isNumberLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"number\" });\n    }\n    if (type.isBoolean() || type.isBooleanLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"boolean\" });\n    }\n    // å¤„ç†å…¶ä»–å­—é¢é‡ç±»åž‹\n    if (type.isLiteral()) {\n        return Object.assign(Object.assign({}, base), { type: \"string\" });\n    }\n    // å¤„ç†æ•°ç»„ç±»åž‹\n    if (type.isArray()) {\n        return Object.assign(Object.assign({}, base), { type: \"array\", items: resolveType({\n                type: type.getArrayElementType(),\n                defNameMap,\n                circularRefs,\n            }) });\n    }\n    if (type.isUnion()) {\n        circularRefs.set(type, type.getText());\n        return Object.assign(Object.assign({}, base), { oneOf: type.getUnionTypes().map((subType) => resolveType({\n                type: subType,\n                defNameMap,\n                extra,\n                circularRefs,\n            })) });\n    }\n    if (type.isIntersection()) {\n        circularRefs.set(type, type.getText());\n        return Object.assign(Object.assign({}, base), { type: \"array\", allOf: type.getIntersectionTypes().map((subType) => {\n                return resolveType({\n                    type: subType,\n                    defNameMap,\n                    extra,\n                    circularRefs,\n                });\n            }) });\n    }\n    // å¤„ç†å¯¹è±¡ç±»åž‹å’Œäº¤å‰ç±»åž‹\n    if (type.isObject()) {\n        circularRefs.set(type, type.getText());\n        return Object.assign(Object.assign({}, base), { type: \"object\", properties: type.getProperties().reduce((map, propSymbol) => {\n                // const debug = collectDebugInfo(null, null, propSymbol);\n                var _a, _b;\n                // èŽ·å–å±žæ€§çš„å£°æ˜ŽèŠ‚ç‚¹\n                const propNode = (_a = propSymbol.getValueDeclaration()) !== null && _a !== void 0 ? _a : propSymbol.getDeclarations()[0];\n                // èŽ·å–å±žæ€§çš„ç±»åž‹\n                const propType = propNode\n                    ? propSymbol.getTypeAtLocation(propNode)\n                    : propSymbol.getDeclaredType();\n                // æ£€æŸ¥å±žæ€§ç±»åž‹æ˜¯å¦æ˜¯å·²å®šä¹‰çš„ç±»åž‹\n                const maybeTypeDecl = (_b = propType.getSymbol()) === null || _b === void 0 ? void 0 : _b.getValueDeclaration();\n                const isDefinedType = maybeTypeDecl && defNameMap.has(maybeTypeDecl);\n                // å¦‚æžœæ˜¯å·²å®šä¹‰ç±»åž‹,ä½¿ç”¨å¼•ç”¨\n                if (isDefinedType) {\n                    map[propSymbol.getName()] = {\n                        $ref: \"#\" + defNameMap.get(maybeTypeDecl),\n                    };\n                    return map;\n                }\n                // é€’å½’å¤„ç†å±žæ€§ç±»åž‹\n                map[propSymbol.getName()] = resolveType({\n                    type: propType,\n                    defNameMap,\n                    circularRefs,\n                });\n                return map;\n            }, {}) });\n    }\n};\nconst parseDefinitions = (definitions) => {\n    const defSchema = {};\n    const defNameMap = new WeakMap();\n    for (const def of definitions) {\n        let clzName = def.getName();\n        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨é‡å¤åç§°\n        if (defSchema[clzName]) {\n            const atFile = def.getSourceFile().getFilePath();\n            const basechain = atFile.split(\"/\");\n            clzName =\n                clzName + \"_At_\" + basechain[basechain.length - 1].replace(/\\.w+/, \"\");\n            let acc = 0;\n            const baseName = clzName;\n            // ç”Ÿæˆå”¯ä¸€åç§°\n            while (defSchema[clzName]) {\n                acc = acc + 1;\n                clzName = baseName + acc;\n            }\n        }\n        defNameMap.set(def, clzName);\n    }\n    for (const def of definitions) {\n        const extra = getNodeExtraInfo(def);\n        let clzName = defNameMap.get(def);\n        const schema = Object.assign(Object.assign({}, extra.merged), { type: \"object\", properties: def.getProperties().reduce((map, prop) => {\n                const extra = getNodeExtraInfo(prop);\n                map[prop.getName()] = resolveType({\n                    type: prop.getType(),\n                    defNameMap: defNameMap,\n                    extra: extra.merged,\n                });\n                return map;\n            }, {}) });\n        defSchema[clzName] = schema;\n    }\n    return { defSchema, defNameMap };\n};\nconst parseOperations = (operations, defNameMap) => {\n    const defMap = {};\n    for (const operation of operations) {\n        const extra = getNodeExtraInfo(operation);\n        const typeNode = operation.getTypeNode();\n        if (Node.isTypeLiteral(typeNode)) {\n            const schema = Object.assign(Object.assign({}, extra.merged), { type: \"object\", properties: typeNode.getProperties().reduce((map, prop) => {\n                    const extra = getNodeExtraInfo(prop);\n                    map[prop.getName()] = resolveType({\n                        type: prop.getType(),\n                        defNameMap,\n                        extra: extra.merged,\n                    });\n                    return map;\n                }, {}) });\n            defMap[operation.getName()] = schema;\n        }\n    }\n    return defMap;\n};\n\nexport { getDtsNodes, getNodeExtraInfo, parseDefinitions, parseOperations };\n"
    }
  }
}